# 类对比数据结构

[Classes vs. Data Structures](https://blog.cleancoder.com/uncle-bob/2019/06/16/ObjectsAndDataStructures.html)

> 什么是一个类？

一个类就是一类相同对象的统称。

> 什么是一个对象？

对象是对封装的数据元素进行操作的一系列功能的集合。

> 或者相反的，对象是运行在隐含数据元素上的一系列功能的集合。

你说的隐藏数据元素是什么意思？

> 对象的函数隐藏着一些数据元素；但是从对象外面不能直接显示或者访问到数据。

那些数据不在对象内？

> 可能是；但是没有规则说必须是这样。从用户的角度来看，一个对象只不过是一系列功能的集合。这些功能运行的数据必须存在，但用户不知道这些数据的位置。

好的，我现在懂了。

> 好的，什么是数据结构？

数据结构是一套具有凝聚力的数据元素。

> 或者，换种说法，数据结构是由隐含函数执行的一组数据元素的集合。

好的好的，我懂了。数据结构上运行的函数并不是由数据结构指定的，而是数据结构的存在意味着一些函数必须存在。

> 对。那么现在你注意到那两个定义有什么区别？

某种程度来说它们有点相反。

> 的确，它们之间有点互补。它们组装在一起就像手和手套一样。

- 对象使基于隐藏数据元素的一组函数的集合
- 数据结构是由隐藏函数操作的一组数据元素

哇，所以对象不是数据结构。

> 正确。对象使数据结构的对立面。

因此一个DTO - Data Transfer Object - 不是一个对象？

> 正确。DTOS是数据结构。

那么数据库中的表也不是对象？

> 正确。数据库包含数据结构，不是对象。

但是等等。一个ORM - Object Relational Mapper - 映射数据库表到对象？

> 当然不是。数据库表和对象之间没有映射。数据库表示数据结构，不是对象。

那ORM是做什么的？

> 它在数据结构之间转换数据。

所以他们没有用对象做任何事？

> 什么都没有。不存在对象关系映射；因为数据库表和对象之间没有映射关系。

但是我以为ORM给我们创建了业务对象。

> 不，ORM提取我们业务对象运行的数据。那些数据包含在ORM加载的数据结构中。

但业务对象不包含数据结构吗？

> 有可能是，也有可能不是。那不是ORM的业务范畴。

那看起来有二义性。

> 根本没有。这一区别有很大影响。

比如说？

> 如数据库schema的设计比对业务对象的设计。业务对象定义了业务行为的结构，数据库schema定义了业务数据结构。这两个结构受到截然不同的制约。业务数据的结构不一定是业务行为的最佳选择。

额，听着有点混乱。

> 试着这样理解。数据库schema不止对一个应用进行调整；它必须服务于整个企业。所以它的结构就必须向很多不同的应用妥协。

是的，我觉得是。

> 好的。现在考虑每个应用。每个应用程序的对象模型描述了这些应用程序的行为程序方式。每个应用程序将有不同的对象模型，以适应该应用程序的行为。

奥，我懂了。由于数据库schema是各种应用的妥协，这种schema将不符合任何特定应用的对象模型。

> 正确。对象和数据结构受到不同的约束。他们很少排好队。人们过去把这种称为对象/关系阻抗不匹配。

我听说过。但我认为阻抗不匹配是由ORM解决的。

> 现在你却不同意见了。没有阻抗不匹配，因为对象和数据结构是互补的，不是同构的。

说明什么呢？

> 它们是对立的，不是相同的实体。

对立的？

> 是的，说起来很有意思。你看，对象和数据结构意味着完全相反的控制结构。

等等，什么？

> 考虑一组对象类它们都符合一个公共的接口。例如，imagine类代表二位图形，它们都有计算面积和周长的函数。

为什么每个软件示例都喜欢用图形来举例？

> 让我们考虑两个不同的类型：正方形和圆形。很显然这两个图形的面积和周长都用不同的数据结构操作。更显然的这些操作被称作动态的多态。

等等，说慢点，是什么？

> 它们有两个不同的面积计算函数，一个是正方形一个是圆形。当调用者调用一个特定的对象的area函数时，那个对象知道调用哪个函数。我们称为动态的多态性。

是的。当然。对象知道方法的具体实现。当然。

> 现在让我们把这些对象转换为数据结构。我们将使用可区分联合。

可区分什么？

> 可区分联合。就我们而言，仅仅是两个数据结构。一个是方形一个是圆形。圆形数据结构包含中心点，和一个半径。它也有一个类型代码来标识它是一个圆形。

你意思像一个枚举？

> 当然。正方形数据结构包含左上点，每个边的长度。它也有类型区分 - enum

好的。两个包含类型的数据结构。

> 对的。现在考虑一下area函数，它会有转换声明，不是吗？

嗯，当然，两种不同的情况。一个是正方形一个是圆形。perimeter函数也需要类似的转换声明。

> 又一次对了。现在考虑下这两种场景的结构。在对象场景中，area函数的两个实现互相独立，属于（在某种程度上的）类型。正方形的面积属于正方形，而圆形的面积属于圆形。

好的，我知道你的意思了。在数据结构场景下两个area函数的实现是在一个函数中，它们不属于类型。

> 它变得更好了。如果要将三角形加入到对象场景中，需要修改哪些代码？

不用修改代码。只需要新建一个Triangle类。奥，我想实例的创建者必须改变。

> 正确，所以当你增加一个新类型，很少的修改。假设你需要增加一个新函数 - center函数。

好吧，那你必须把它增加到三种类型中，正方形，圆形和三角形。

> 很好。所以增加新函数是困难的，你必须修改每个类。

但是它们的数据类型是不同的。为了增加Triangle你需要改变每个函数，以便将三角增加到转换声明中。

> 正确，增加一个新类型是困难的，你必须修改每个函数。

但是当我增加center函数，什么都没有改变。

> 是的，增加函数很容易。

哇，正好相反。

> 事实上是的。让我们回顾下：

- 给一组类增加新函数是困难的，你必须改变每个类
- 给一组数据结构增加新函数是容易的，你仅仅增加函数，别的不用改变
- 给一组类增加新的类型是容易的，你仅仅增加新的类
- 给一组数据结构增加新类型是困难的，你需要改变每个函数

有趣的理论。我知道，如果你知道将在一系列类型中增加新的函数，你应该使用数据结构。但如果你将增加新的类型，你应该使用类。

> 理解的不错。但是最后还有一个问题需要讨论。还有一种数据结构和类对立的方式，这与依赖有关。

依赖？

> 是的，代码直接依赖。

好吧，我听着呢，区别是什么？

> 考虑数据结构案例。每个函数都有转换声明，根据区分联合内部的类型代码选择合适的实现。

好的，没错，那又是什么呢？

> 考虑下调用area函数。调用者依赖area函数，area函数又依赖于每个实现。

你说的依赖是什么？

> 想象下area的每个实现。就会有circleArea，squareArea和triangleArea。

好的，转换声明调用这些函数。

> 想象下这些函数分布在不同的源文件中。

那么有转换声明的这些源文件就需要导入，或使用，或包含那些源文件。

> 正确，这就是代码依赖。一个源文件依赖另一个源文件。这种依赖的方向是什么？

有转换声明的源文件依赖包含实现的。

> 那area函数的调用者呢？

area函数的调用者即依赖转换声明的源文件又依赖所有实现的。

> 正确。所有源文件依赖指向调用方，从每个实现的调用者。所以如果你对其中一个实现做了改动...

好的，我知道你要说什么了。任何一种实现的改变都会导致带有转换声明的源文件重新编译，这将导致所有调用转换声明的都需要重新编译。

> 正确。至少对于依赖于源文件日期来确定哪些模块应该被编译的编程语言来说是如此。

它们几乎都是动态类型，对吗？

> 是的，某些是某些不是。

这会导致很多重新编译。

> 还有很多重新部署。

但是在类中，这种情况正好相反。

> 是的，因为调用area函数的依赖于接口，实现的函数也依赖于接口。

我懂你意思了。Square类的源文件导入，或使用，或包含了Shape接口。

> 正确。实现的源文件方向正好相反。它们从实现指向调用方。至少静态类型语言是这样。动态类型语言area函数的调用者什么也不依赖。这些联系是在运行时建立起来的。

好的，所以如果你需要改变一个实现...

> 仅仅修改的文件需要被重新编译。

这是因为源文件中的依赖关系指向调用方。

> 是的。我们称为依赖转换。

好的，那我试着总结一下。类和数据结构有三种不同点：

- 类使得函数可见同时保持数据隐藏。数据结构使得数据可见，同时保持函数隐藏。
- 类可以很容易的增加类型但是增加函数就很困难。数据结构很容易的增加函数但是增加类型就很困难。
- 数据结构使调用者面临重新编译和重新部署的风险。类隔离了调用者重新编译和重新部署。

> 你已经掌握了。这是每个优秀的软件设计人员和架构师需要注意的。
