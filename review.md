# 动态库vs静态库性能比较

[Dynamic (shared) vs. Static Library Performance](https://link.medium.com/BXzp7MtM1Y)

内容摘要：

- 什么是共享库
- 如何创建共享库
- 他们有什么用处
- 和静态库比较有什么不同

## 什么是共享库

共享库就是说当用户编译一个.c文件可以被动态链接的库。静态链接和动态链接在收集结合多个对象文件创建成单个可执行文件是两个不同的过程。最主要的不同就是在创建可执行文件时两种链接时不同的类型。

相反的比起静态库，在Linux中动态库链接就像执行一个程序。此外，动态库在执行的时候会被加载到内存中。在编译期间，共享库机器码会被缓存到本地并且会有版本控制排序以便追踪哪些文件会被更改。

下面让我们创建一个共享库来测试下。下一步，你应该给共享库增加一些代码。然后，当你重新编译后，编译程序会将增加的那部分修改缓存进来，不像静态编译是全量编译一遍。

## 如何创建共享库

下面我们有一些文件需要编译到共享库。file0.c, file1.c, file2.c和一个头文件fheader.h。

每一个函数目的和原型都包含在头文件中。用下面的命令来创建动态库：

> $ gcc -fPIC -Wall -Werror -Wextra -pedantic *.c -shared -o libfile.so

- -fPIC选项打开代码位置对齐(position independent code)，允许代码运行时位于任何虚拟地址。
- -Werror选项打开警告
- -Wextra选项确保类型比较是有效的
- -pedantic选项确保代码符合ISO标准
- -shared选项指定创建的共享库有一个.so的扩展名
- -o选项允许指定生成的文件名
- 最终结果：libfile.so

## 如何使用

回到上一节示例中的文件我们创建了另外一个叫file3.c且以来其他文件的原型。我希望增加这个新的代码到仓库中首先我们需要编译它。当我们增加更多的文件我希望使用动态库。就像下面：

> $ gcc -Wall -Werror -Wextra -pedantic -L. file3.c libfile -o foo

- -L.选项告诉连接器从当前路径开始查找
- file3.c是引入动态库且包含了#include "header.h"头文件可以执行我们的程序
- -libfile选项指定了我们要用到的动态库
- -o指定新创建的可执行文件名字

下一步，我们需要设置环境变量LD_LIBRARY_PATH到我们的.so文件。这样编译器可以在运行时链接。

> $ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH

下一步，我们需要将它安装到Linux机器的文件目录中：

> $ export LD_LIBRARY_PATH=$HOME/lib:$LD_LIBRARY_PATH

## 和静态库比较有什么不同

静态库速度快并且所有的原型都单独一个文件，但是，你在编译的时候需要不断的加载每个文件。并且，可执行文件从引入静态库以后会大很多。这种非常适合嵌入式系统应用是因为整个程序生态系统需要在一个区域中。例如，一个起搏器被手术植入人体内并且设备需要访问所有的库。当植入人体内需要整个库来链接到你的可执行文件和所有的内存位置。

动态库执行稍微慢一些、兼容性差一点，但是，能快速编译和减少可执行文件的尺寸大小。在嵌入式系统需要联网升级这种就有优势。
